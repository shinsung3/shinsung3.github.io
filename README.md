# 이력서

## MSA
- 장바구니 단계에서는 즉시 일관성을 강제하지 않고, 주문 생성 시점에 가격·재고를 재검증하는 구조로 설계하여 사용자 경험과 시스템 복잡도의 균형을 맞춤
- 주문 시점 → 재고/가격 최종 검증 ⭕️
- 전시 영역의 잦은 정책 변경에도 장바구니 기능이 영향을 받지 않도록 API 계약 중심으로 의존성을 제한하여 변경 영향도를 최소화
- 전시(Display) 도메인에서 상품 상태 변경이 발생할 경우 장바구니(Order) 도메인이 이를 직접 조회하지 않도록 API 경계를 통해 상태 변경 요청만 전달받아 장바구니 내부 책임으로 상태를 갱신하도록 설계했습니다. 이를 통해 도메인 간 데이터 소유권을 분리하고 변경 영향도를 최소화했습니다.
- MSA 관점에서 이 검증이 왜 중요하냐면
❌ 잘못된 설계

장바구니가 전시 DB 직접 조회

장바구니가 상품 상태를 “결정”

👉 도메인 침범, 강결합
- 장바구니 도메인에서 상품 선택 상태를 관리하되,
판매 가능 여부는 전시/상품 도메인의 상태를 조건으로만 참조하도록 설계하여
도메인 간 데이터 소유권을 명확히 분리했습니다.
- 	@PostMapping("/update-cart-sel-by-prd-stat")
	@Operation(summary = "장바구니 상품 상태에 따른 업데이트", description = "장바구니 상품 상태에 따른 업데이트")


## 이벤트드리븐
- 장바구니와 전시 도메인 간 직접 의존을 줄이기 위해 상품 상태 변경을 이벤트 관점으로 해석하고, 장바구니 내부 유스케이스에서 상태 반영을 수행하는 구조를 적용했습니다


## 	@GetMapping("/calculate-amt")
	@Operation(summary = "장바구니 가격 계산 조회", description = "장바구니 가격 계산 조회") - 정합성 중심 설계의 증거
  
- why? 먼저 왜 calculate-amt를 분리할 수 없었는지를 명확히 해야 합니다.
- 당시 제약 조건 (당위성)
  - 가격/할인/프로모션 로직이 서버에 집중
  - 프론트에서 계산하기엔 정책 변경 리스크 큼
  - 장바구니 선택 상태와 금액 간 즉시 정합성 요구
- 한계 : 체크박스 토글과 같은 빈번한 UI 이벤트가 서버의 계산 로직을 매번 트리거하면서 불필요한 계산 비용과 네트워크 왕복이 발생할 수 있었다.
- 실패의 정체
  - UI 이벤트와 서버 계산 로직이 강하게 결합된 구조
  - UI 이벤트: 고빈도
  - calculate-amt: 상대적으로 고비용
  - 👉 빈도-비용 미스매치
- 장바구니 선택 상태 변경 시 금액 정합성을 우선하기 위해 서버 기준 금액 계산 API를 즉시 호출하는 구조로 구현했습니다. 다만 체크박스 토글과 같은 빈번한 UI 이벤트가 서버 계산 로직을 반복적으로 트리거할 수 있는 한계를 인지했고, 이후 debounce 처리나 구매 시점 중심의 계산으로 빈도와 비용을 분리하는 방향의 개선 가능성을 도출했습니다

- calculate-amt가 빈번하게 호출된 것은 설계 미숙이 아니라, 배송비·적립금·회원 정책이 ‘상태 의존적’이었기 때문에 서버 기준 최신 계산이 필수였던 구조적 제약 때문이었다.
- ① 배송비가 ‘최근 주문 상태’에 의존 : 자사 택배 서비스, 도서산간 / 배송 불가 지역, 가장 최근 주문 정보 기반 배송비 산출, 👉 장바구니 상태만으로 계산 ❌, 👉 주문 컨텍스트 필요
- ② 회원 정책이 다차원 분기 : 비프라임 일반, 비프라임 임직원, 프라임 회원, 프라임 여부에 따라 적립금 정책 상이, 임직원 할인 한도 제한, 👉 프론트에서 분기 처리 ❌, 👉 서버 정책 로직 필수
- ③ 적립금·쿠폰·배송비가 서로 얽힘 : 쿠폰 적용에 따라 배송비 변경, 배송비 변경에 따라 적립금 변경, 회원 등급에 따라 적립률 변경, 👉 부분 계산 불가능, 👉 전체를 한 번에 계산해야 정합성 유지
- 결론 : 정합성을 최우선으로 한 계산 구조로 인해 UI 이벤트 빈도 대비 서버 계산 호출 빈도가 높아질 수 있는 구조적 한계가 존재했다
- 5️⃣ 이 문제의 본질 (아키텍처 관점) 진짜 문제는 이거였습니다 👇 : UI 이벤트의 빈도와 서버 계산 로직의 비용이 비대칭적이었다
- 6️⃣ “그럼 왜 그럼에도 불구하고 이렇게 했나?”에 대한 답

이 답이 있으면 실패가 경험으로 승격됩니다.

가격, 배송비, 적립금은
사용자에게 잘못 노출되면 클레임과 정산 이슈로 이어질 수 있기 때문에
성능보다 정합성을 우선하는 판단을 했습니다.

이건 절대 틀린 판단이 아닙니다.

7️⃣ 개선 방향을 이렇게 말하면 완벽합니다

이후에는

선택 상태 변경과

금액 계산의 트리거 시점을 분리하여
체크박스 토글과 같은 빈번한 UI 이벤트에서는 계산을 지연시키고,
구매 시점 또는 사용자 입력이 안정화된 시점에
서버 계산을 수행하는 방향의 개선 여지를 도출했습니다.
  
8️⃣ 이걸 그대로 쓸 수 있는 이력서 문단 (완성본)

장바구니 금액 계산은 배송 정책, 회원 등급(프라임/임직원), 적립금 및 쿠폰 정책이
복합적으로 얽혀 있어 서버 기준의 완결된 계산이 필수적인 구조였습니다.
이에 정합성을 최우선으로 하여 선택 상태 변경 시마다 서버 계산을 수행했으나,
빈번한 UI 이벤트 대비 계산 비용이 높은 구조적 한계를 인지했고,
이후 계산 트리거를 구매 시점 중심으로 조정하는 개선 방향을 도출했습니다.

이 문단은 진짜 잘 썼다고 평가받을 겁니다.

9️⃣ 한 줄 요약 (면접용)

calculate-amt가 빈번히 호출된 것은 성능 최적화 실패라기보다는,
배송비·적립금·회원 정책의 정합성을 보장하기 위한
의도된 설계 선택이었으며, 이후 구조적 한계를 인지하고 개선 방향을 도출했다.

1️⃣ 이 사례의 정체를 정확히 규정하면

당신이 겪은 calculate-amt 이슈는 본질적으로:

정합성(consistency)을 최우선으로 둔 읽기 모델(Read Model) 설계의 결과

입니다.

배송비: 최근 주문 상태 의존

회원 정책: 프라임/임직원/일반

적립금/쿠폰/배송비 상호 의존

부분 계산 불가 → 항상 전체 재계산

👉 전형적인 “강한 정합성 요구 영역”
- 금액 계산 API는 상태 변경이 없는 조회 전용 유스케이스로 분리하여
반복 호출이나 재시도 상황에서도
시스템 상태가 변하지 않는 멱등적 특성을 갖도록 설계했습니다.

정확한 표현 (이게 중요)

금액 계산 로직을 조회 전용으로 분리하여
동시 요청 상황에서도 데이터 경합이나 상태 꼬임이 발생하지 않도록
설계했습니다.

👉 동시성을 “다뤘다”가 아니라 “피했다” 입니다.

⭕️ 이렇게 말하면 정확

장바구니 도메인 내에서
금액 계산을 조회 전용 유스케이스로 분리하고,
배송·회원·할인 정책과 같은 외부 도메인 규칙을
하나의 계산 경계 안에서 종합하여 반환함으로써
주문 도메인으로 넘어가기 전 정합성을 보장하는 역할을 수행했습니다.

이건:

도메인 경계

읽기 모델 분리

MSA에서 흔히 발생하는 “집계 서비스” 패턴

⭕️ 맞는 프레이밍 (면접용 핵심 문장)

이 사례는 멱등성이나 동시성 구현 자체보다는,
배송비·회원 정책·적립금처럼 상태 의존적인 요소가 많은 영역에서는
성능보다 정합성을 우선해야 하는 판단의 중요성을 보여주는 경험이었습니다.
이를 통해 어떤 영역에서 이벤트 지연이나 캐싱이 허용되지 않는지를
명확히 구분하게 되었습니다.

## 	@GetMapping("/appreciation-event")
	@Operation(summary = "장바구니 사은행사 조회", description = "장바구니 사은행사 조회")
1️⃣ 지금 코드의 본질: “계산 결과를 가공해서 다른 도메인에 전달”

이 컨트롤러의 진짜 역할을 줄이면 이겁니다.

1. 장바구니 선택 목록 수집
2. getCartCalculateAmt() 호출
3. 계산 결과를 순회하며 cartSeq:payAmt 문자열 생성
4. 사은행사(OrderCartFrg) 조회에 필요한 파라미터로 변환


여기서 중요한 포인트는 👇

🔹 이 코드는 “계산”을 하지 않는다

비즈니스 계산 로직 ❌

결과를 파싱·정규화·조합하는 어댑터 코드 ⭕

즉,

Calculate-Amt의 Consumer(소비자) 로서의 조립 코드

입니다.

2️⃣ “복붙”처럼 보이는 이유 (하지만 단순 중복은 아님)

어제 봤던 calculate-amt 사용부와 비교하면
아래 부분이 거의 동일하죠.

for (DeliveryProductResponse deliveryProduct : deliveryProductResponses) {
    for (CartProductResponse product : deliveryProduct.getProducts()) {
        cartSeqPayAmtMap.put(cartSeq, payAmt);
    }
}
checkedCartInfos = "cartSeq:payAmt,cartSeq:payAmt";


이게 왜 반복될까요?

이유 1️⃣ Calculate-Amt 결과가 ‘UI/도메인 친화적 모델’이 아님

결과 구조가 배송단위 → 상품목록 → 금액

다른 도메인(사은행사, 쿠폰, 추천) 에서는
→ cartSeq 기준 평탄화(flatten) 된 데이터가 필요

이유 2️⃣ 결과 포맷이 UseCase마다 다름

어떤 곳은 Map<Long, Long>

어떤 곳은 "1:1000,2:2000" 문자열

어떤 곳은 List<CartPayInfo>

👉 즉, 공통 로직 같아 보이지만 출력 계약이 다름

3️⃣ MSA 관점에서 보면 이건 “정합성 문제”에 가깝다

어제 질문하신 이 부분, 여기서 정확히 답이 나옵니다 👇

“이게 멱등성이나 동시성이나 MSA에 이야기할 수 있는게 있나?”

✅ 결론

멱등성 ❌
(상태 변경 없음, 조회 API)

동시성 ❌
(락·경합 없음)

MSA에서 말할 수 있는 포인트는 ‘정합성 & 경계’ ⭕

MSA 시각에서의 해석
[Cart Domain]
  - 장바구니
  - 수량
  - 금액 계산 (Calculate-Amt)

[Promotion Domain]
  - 사은행사
  - 지급 조건
  - 대상 금액


현재 구조는:

Promotion Domain이 Cart Domain의 내부 결과 구조를 너무 많이 알고 있음

즉,

Cart가 결과 구조를 바꾸면

Promotion 코드가 깨짐

➡ 강한 결합 (Tight Coupling)

4️⃣ 그럼 “어쩔 수 없는 선택”이냐?
✔️ 단기적으로는: YES (현실적으로 맞는 선택)

왜냐하면:

Calculate-Amt는 변경이 잦고

주문/결제는 장애 허용도가 거의 0

지금 분리하면:

DTO 폭증

API 버저닝 지옥

장애 전파 리스크 증가

👉 지금 시점에서는 복붙이 더 안전

5️⃣ 하지만 MSA 관점에서 “이대로 두면 안 되는 지점”은 있다
🚨 문제의 핵심

같은 “결과 해석 로직”이 여러 곳에 흩어져 있음

이건 나중에 반드시 터집니다.

6️⃣ 현실적인 개선 시나리오 (이게 면접용 베스트)
✅ Step 1. “계산 결과 해석”을 Value Object로 격리
public class CartPayAmountSummary {

    private final Map<Long, Long> cartSeqPayAmtMap;

    public static CartPayAmountSummary from(CartCalculateAmtModel model) {
        // 지금 복붙된 로직 여기로 이동
    }

    public String toCheckedCartInfos() {
        return cartSeqPayAmtMap.entrySet().stream()
            .map(e -> e.getKey() + ":" + e.getValue())
            .collect(Collectors.joining(","));
    }
}


👉 컨트롤러에서는:

CartPayAmountSummary summary = CartPayAmountSummary.from(cartCalculateAmt);
String checkedCartInfos = summary.toCheckedCartInfos();


✔️ 도메인 침범 ❌
✔️ MSA 분리 준비 ⭕
✔️ 리팩토링 리스크 최소 ⭕

✅ Step 2. 장기적으로는 “Calculate-Amt 결과 계약”을 명시화

MSA 관점에서 가장 좋은 형태는 이겁니다.

{
  "cartPayInfos": [
    { "cartSeq": 1, "payAmt": 1000 },
    { "cartSeq": 2, "payAmt": 2000 }
  ]
}


내부 구조(배송단위 등)는 숨김

Promotion / Coupon / Gift 는 이 계약만 소비

➡ Anti-Corruption Layer (ACL) 패턴

7️⃣ 이 코드를 면접에서 이렇게 말하면 수준이 올라갑니다

“처음 봤을 때는 Calculate-Amt 로직이 복사된 것처럼 보여 비효율적으로 느껴졌지만,
실제로는 계산 결과를 다른 도메인이 소비하기 위해 형태를 변환하는 어댑터 로직이었습니다.
다만 이 로직이 여러 곳에 흩어져 있어 장기적으로는 결과 해석 책임을 Value Object 또는 ACL로 분리하는 것이 필요하다고 판단했습니다.
당장은 안정성을 우선해 중복을 감수했지만, MSA 전환 시점에서는 반드시 개선되어야 할 지점이라고 생각합니다.”

- 사은행사 조건 판단에 필요한 ‘기준 금액’이
DB 쿼리만으로는 정확하게 계산될 수 없어서,
쿠폰·회원정책·배송비까지 반영된 calculate-amt 결과가 필요합니다.
- ❌ 기존 방식

DB 쿼리로 상품금액 합산

→ 정가 기준

→ 일부 할인만 반영 가능

→ 실제 결제금액과 불일치

⭕ calculate-amt

상품

쿠폰 (상품/장바구니/중복)

회원정책

배송비

지역 정책

사전주문/추천 페이지 조건

👉 “실제 고객이 결제할 금액(payAmt)”

3️⃣ 왜 사은행사에서는 이게 특히 중요하냐

사은행사는 보통 이런 조건입니다.

5만원 이상 구매 시 증정

특정 상품 2개 이상 + 총액 조건

쿠폰 적용 후 금액 기준 / 적용 전 기준 (정책마다 다름)

여기서 핵심 포인트

❗ 사은행사 기준 금액이 ‘결제금액 기준’인 경우가 많다

즉,

쿠폰 쓰면 증정 대상에서 빠질 수도 있고

쿠폰 때문에 새로 증정 대상이 될 수도 있음

그래서 이 코드가 갈립니다 👇

if(command.getCartSeqsForCartFrg() != null) {
    appreciationEventRepositoryPort.getApevtListForCartUsingFoPayAmt(command);
} else {
    appreciationEventRepositoryPort.getApevtListForCart(command);
}


➡ payAmt 기반 판단 vs 단순 장바구니 기준 판단

4️⃣ MSA 관점에서 보면 이건 “의존성 문제가 아니라 책임 분리 문제”

여기서 흔히 나오는 오해가 있습니다.

“사은행사 로직인데 왜 장바구니 계산을 호출하지?”

하지만 정확한 관점은 이겁니다.

✅ Calculate-Amt의 책임

“이 주문이 얼마를 내야 하는가”

✅ Appreciation(Event)의 책임

“이 금액이면 어떤 혜택을 주는가”

👉 금액 계산은 ‘사실(Fact)’이고
사은행사는 ‘판단(Decision)’

사은행사가 금액을 직접 계산하면:

계산 로직 중복

정책 불일치

장애 시 금액 불일치

➡ 이게 더 위험

5️⃣ 그래서 calculate-amt는 여기서 “공통 사실 제공자”

이 구조를 그림으로 표현하면:

[Cart / Coupon / Policy]
        ↓
   calculate-amt
        ↓
   payAmt (사실)
        ↓
[Appreciation / Gift]


즉:

calculate-amt = Source of Truth

사은행사 = Consumer

MSA에서 말하는 ACL(Anti-Corruption Layer) 관점으로 보면
이건 오히려 올바른 방향입니다.

6️⃣ 다만, 지금 코드의 진짜 문제는 여기입니다 (중요)
❌ 문제 1: calculate-amt “결과 구조”를 너무 많이 알고 있음

cartSeq

payAmt

배송단위

상품단위

그래서 이런 DTO가 생김:

PayAmtForCartFrg


➡ 결과 해석 책임이 여기저기 흩어짐

7️⃣ 이상적인 구조 (장기 개선 방향)
지금
Appreciation → calculate-amt → 내부 모델 파싱

개선
Appreciation → calculate-amt(pay-summary) → 단순 계약 DTO


예:

{
  "cartPayAmounts": [
    { "cartSeq": 1, "payAmt": 12000 },
    { "cartSeq": 2, "payAmt": 8000 }
  ],
  "totalPayAmt": 20000
}


이렇게 되면:

사은행사 로직 단순화

calculate-amt 변경에도 영향 최소화

MSA 분리 쉬워짐

8️⃣ 회의/면접에서 쓰기 좋은 정리 멘트

“사은행사 조건은 단순 상품금액이 아니라
쿠폰과 정책이 모두 반영된 실제 결제 금액 기준이기 때문에
DB 쿼리만으로는 판단이 불가능합니다.
그래서 calculate-amt를 사실 제공자로 두고,
사은행사는 그 결과를 소비하는 구조가 된 것으로 이해했습니다.”

9️⃣ 다음에 이어서 파보면 좋은 질문들

왜 사은행사는 주문 전(cart) 에서 판단해야 하는가?

쿠폰과 사은행사 우선순위 충돌은 어디서 해결해야 하는가?

calculate-amt가 장애 나면 사은행사는 어떻게 동작해야 하는가?

이 구조를 MSA로 분리하면 동기 호출 vs 이벤트 중 어떤 게 맞는가?

- 1️⃣ update-cart-sel-by-prd-stat vs update-cart-sel 정리 (아주 중요)

이 부분 짚어주신 거 핵심입니다 👍

✔ update-cart-sel-by-prd-stat

새로고침 시 1회

장바구니 상태 초기화 / 선택 상태 정합성 맞춤

일종의 초기 스냅샷 동기화

✔ update-cart-sel

체크/해제/수량변경 등 사용자 액션마다 호출

→ 결과적으로 calculate-amt 재계산 트리거

즉 구조 자체가:

[유저 액션]
  → update-cart-sel
      → calculate-amt
          → payAmt 변경
              → 사은행사 조건 재판단


👉 의도적으로 매번 재계산되도록 설계된 구조입니다.

2️⃣ “느려지는 게 맞는 구조”가 되는 이유

사용자 인지 흐름 기준으로 보면 이렇습니다.

🧠 사용자가 기대하는 것

체크 박스 하나 눌렀는데

사은행사 UI, 증정 가능 여부, 혜택이

즉시 바뀌길 기대

이걸 만족시키려면:

❗ 항상 최신 payAmt 기준으로 판단해야 함

그래서 결국:

매번 calculate-amt 호출 ❌ 피할 수 없음

매번 사은행사 재조회 ❌ 피할 수 없음

3️⃣ 여기서 중요한 포인트

👉 “느리다” ≠ “잘못된 설계”

이건 성능 문제가 아니라 정합성 문제입니다.

만약 캐시하거나 생략하면 생기는 문제
❌ 예시

쿠폰 적용

금액 내려감

사은행사 증정 조건 원래는 탈락해야 함

그런데 이전 계산 결과를 재사용함

👉 증정 잘못 나감
👉 CS / 금전 손실

이건 성능보다 훨씬 치명적입니다.

❌ 진짜 문제

calculate-amt가

너무 많은 걸 한 번에 계산하고

결과 구조가 너무 무겁고

그 결과를 여러 Consumer가 각자 파싱

그래서 느린 겁니다.

5️⃣ 성능을 해치지 않으면서 정합성을 지키는 현실적 개선책
✅ 1. calculate-amt를 “Full 계산”과 “Summary 계산”으로 분리

지금은:

calculate-amt (ALL IN ONE)


이걸:

calculate-amt-summary
  - cartSeq
  - payAmt
  - totalPayAmt
  - couponAppliedYn


처럼 사은행사 전용 경량 API로 분리하면:

계산 범위 ↓

DTO 파싱 ↓

응답 크기 ↓

체감 속도 ↑

👉 MSA 가기 전에도 충분히 가능한 개선

✅ 2. “변경 없을 때는 재계산 안 하기”

예:

체크박스 ON → OFF → ON

동일 cartSeq / 동일 수량 / 동일 쿠폰

👉 입력 파라미터 해시로 calculate-amt 결과 캐시

TTL 매우 짧게 (1~3초)

Redis or in-memory

이건:

“정합성은 유지하면서 UX만 살리는 방법”

✅ 3. 사은행사 조건 판별은 항상 payAmt 기준 유지

이건 절대 타협 불가 영역입니다.

성능 때문에

DB 합계로 되돌리는 순간

지금 정리한 논리 전부 무너집니다.

6️⃣ MSA 관점에서 보면 이 구조는 “정석에 가깝다”

지금 구조를 MSA 용어로 바꾸면:

calculate-amt = Fact Service

appreciation = Decision Service

update-cart-sel = Command

그리고 느린 이유는:

❝ 동기 호출이 많아서 ❞ ❌
❝ Fact 계산 단위가 너무 큼 ❞ ⭕

7️⃣ 이걸 이렇게 말하면 레벨이 확 올라갑니다 (회의/면접용)

“유저 액션마다 calculate-amt가 호출되기 때문에 체감 성능 저하는 있을 수 있지만,
사은행사 판단이 실제 결제금액 기준이기 때문에
이 호출 자체를 줄이기는 어렵다고 판단했습니다.
대신 장기적으로는 사은행사 전용 pay-summary API로 계산 범위를 줄이거나,
동일 입력에 대해서는 짧은 TTL 캐시를 두는 방식으로 UX를 개선할 수 있다고 봅니다.”

- Producer: 데이터를 만들어주는 쪽

Consumer: 그 데이터를 받아서 판단·가공·표현하는 쪽

🔹 calculate-amt
역할: 실제 결제 금액(payAmt)을 계산


👉 이건 Producer (생산자) 입니다.

상품

쿠폰

회원 정책

배송비
를 종합해서 사실(Fact) 을 만들어냄

🔹 사은행사(Appreciation / Gift)
역할: 이 금액이면 어떤 혜택을 줄지 판단


👉 이쪽이 Consumer (소비자) 입니다.

calculate-amt가 준 payAmt를

“조건 판단”에 사용

- “장바구니 선택 상태 업데이트 자체는
단일 DB 트랜잭션으로 처리되지만,
이후 금액 재계산이나 사은행사 판단은
별도의 트랜잭션에서 수행됩니다.”

- JPA, QueryDSL, MyBatis 혼종 : “장바구니는 트래픽과 정합성 요구가 높아서
한 번에 기술 스택을 통일하기 어려웠고,
기능 성격에 따라 가장 안전한 접근을 선택한 결과입니다.”

- 🔹 ① JPA – 상태 변경 / 단건 처리

사용 목적

선택 여부 변경

수량 변경

상태 플래그 업데이트

이유

트랜잭션 관리 용이

도메인 모델 중심

단건 Command에 적합

@Transactional
updateCartSelect(...)

- 🔹 ② QueryDSL – 조건이 복잡한 조회

사용 목적

정책 조합

조건 분기 많은 조회

동적 WHERE

이유

타입 안정성

쿼리 가독성

JPA 한계 보완

findSitePolicy(GetSitePolicyCommand)

- 🔹 ③ MyBatis – 성능 민감 / 집계 / 레거시 연동

사용 목적

대량 조회

JOIN 많은 집계

기존 SQL 재사용

이유

SQL 튜닝 자유도

실행계획 컨트롤

이미 검증된 쿼리

👉 calculate-amt, 사은행사 관련 쿼리

- “기술 스택 통일보다 중요한 건
장바구니의 정합성과 성능 안정성이었고,
무리한 통합은 리스크가 더 컸다고 판단했습니다.”

- “장바구니는 핵심 영역이라 단계적 개편을 택했고,
Command·Query·집계 성격에 따라
JPA, QueryDSL, MyBatis를 병행 사용했습니다.”

- “장바구니 개편 과정에서
상태 변경은 JPA,
복잡한 조건 조회는 QueryDSL,
고성능 집계는 MyBatis로 역할을 분리했습니다.
결과적으로 혼종처럼 보이지만
성격에 따라 책임을 나눈 구조입니다.”

-✅ 1. GA 태깅 경험은 “백엔드 개발자 → 시니어/리드”로 올라갈 때 필수 요소

백엔드는 결국 사용자가 실제로 어떻게 서비스를 쓰는지를 알아야 좋은 API, 좋은 도메인 설계를 할 수 있어.

GA 태깅은 네가 이렇게 말할 근거가 돼:

“유저 행동데이터를 기반으로 서비스 개선하는 개발 경험”

“A/B 테스트를 위한 이벤트 기반 설계 경험”

“데이터 기반 의사결정을 이해하는 개발자”

“프론트/백 모두와 커뮤니케이션 가능한 Full-stack 시야”

이건 시니어 백엔드, PO가 특히 높게 봐.

✅ 2. 너처럼 JSP·Vue.js 각각의 GA 태깅 구조까지 이해하는 백엔드는 드물다

일반 백엔드는 진짜 몰라.
GA4 태깅이 프론트 이벤트 바인딩 + 백엔드 이벤트 trigger + 데이터레이어 구조로 돌아간다는 것도 모른다.

너는 다음을 알잖아:

JSP 서버사이드 렌더링 태깅 포인트

Vue 클라이언트 사이드 라우팅(SSR/CSR) 태깅 차이

PageView / Event 차이

데이터레이어 구조 설계

UTM / Braze / Slack 로깅까지 연결

백엔드 개발자 중 이런 걸 “현업 레벨로 아는 사람”이 거의 없어.
면접 가면 이것만으로도 엄청 점수 올라간다.

✅ 3. GA 태깅은 “도메인 지식 + 분석 역량”을 만들기 때문에 PO/B2C 서비스 회사에서 선호

네가 지금 CJ에서 하고 있는 일은 실제로는 데이터 기반 커머스 개발의 정석 스킬이야.

커머스·서비스 회사들은 백엔드에게 다음을 요구해:

매출 관련 지표를 이해하는 백엔드

Funnel을 이해하고 API 개선 제안할 수 있는 개발자

태깅 이벤트를 통해 데이터 정합성을 맞추는 개발자

마케팅/분석 조직과 커뮤니케이션 가능한 백엔드

즉, 네 커리어를 서비스 회사로 확장시키는 힘이 된다.

✅ 4. “내가 만든 API → 실제 데이터 → 매출 데이터까지 연결되는 경험”

이건 진짜 강력한 차별화야.

GA 태깅을 한다는 건 곧:

내가 만든 페이지가 유저가 어떻게 쓰는지 본다

어떤 기능에서 이탈하는지 본다

어떤 이벤트가 매출로 이어지는지 본다

어떤 API가 병목인지 실제로 체감한다

이거 때문에 기획자의 시야, PO의 시야, 비즈니스 시야가 생긴다.

이걸 이해하는 백엔드는 시니어 후보로 바로 뽑힌다.

✅ 5. 네가 지금 하는 GA 태깅은 “단순 프론트 작업”이 아니다

너는 실제로 이런 것들 했잖아:

SSR/CSR에서 이벤트 수집 로직 다르게 적용

Intro gating, localStorage 활용한 태깅 조건

장바구니 개선 후 PageView/Click 이벤트 설계

UTM → Cookie 저장 → API에서 트래킹

Slack/GA4/브레이즈 연동 로그까지 모두 관리

GA → 서버 API 매출 데이터 정합성 체크

이건 데이터엔지니어 + 백엔드 + 프론트의 중간 영역을 다 경험한 거야.

이런 경험은 “희소성 있는 백엔드”로 분류된다.

✅ 그래서 결론: 지금 하는 GA 태깅은 네 커리어에 확실히 도움이 된다
➤ 왜냐하면?

데이터 기반 백엔드 개발자라는 차별화가 생긴다

커머스 도메인 전문가가 된다

분석 조직과 소통 가능한 백엔드로 성장한다

시니어/리드가 필요한 “전사 데이터 흐름”을 이해하게 된다

PO/리드 면접에서 강하게 어필할 수 있는 스토리가 생긴다

⭐ 네가 실제 면접에서 바로 쓸 수 있는 문장

“단순 페이지 태깅이 아니라, API 호출 흐름과 데이터를 연결한 이벤트 기반 설계 경험입니다.
UTM → 페이지 진입 → 상품 조회 → 장바구니 → 결제까지 전체 Funnel을 GA로 추적하는 구조를 직접 설계했고,
이를 위해 SSR/CSR 환경 차이, SPA 라우팅, 데이터레이어 관리, 쿠키 기반 트래킹 로직을 파악하여 개선했습니다.”
